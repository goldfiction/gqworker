// Generated by CoffeeScript 1.12.7
(function() {
  var Worker, async, cluster, forkCluster, http, log, runAsThread, running, threadHandler, workerThreads;

  workerThreads = require('webworker-threads');

  Worker = workerThreads.Worker;

  cluster = require('cluster');

  http = require('http');

  running = require('is-running');

  async = require('async');

  log = require('util').log;

  runAsThread = function(method, o, cb) {
    var thread;
    thread = workerThreads.create();
    return thread["eval"](method)["eval"]('method(' + JSON.stringify(o) + ')', function(e, r) {
      cb(e, r);
      return thread.destroy();
    });
  };

  exports.runAsThread = runAsThread;

  threadHandler = function(handler, req, res) {
    var o;
    o = req.body || req.query || {};
    return runAsThread(handler, o, function(e, r) {
      if (e) {
        return res.send(404, JSON.stringify(e));
      } else {
        return res.send(200, r);
      }
    });
  };

  exports.threadHandler = threadHandler;

  forkCluster = function(payload, o, cb) {
    var arr, closeWorker, eachWorker, getWorkers, i, j, numCPUs, numWorkers, ref, restartAllWorker, shutDownAllWorker, shutDownServer, updateMasterPID;
    o = o || {};
    numCPUs = o.numCPUs || require('os').cpus().length;
    numWorkers = o.numWorkers || (numCPUs * 2);
    o.cluster = cluster;
    cb = cb || function() {};
    if (cluster.isMaster) {
      updateMasterPID = function() {
        return eachWorker(function(worker) {
          var e;
          try {
            return worker.send({
              masterpid: process.pid
            });
          } catch (error) {
            e = error;
          }
        });
      };
      process.once('SIGQUIT', function() {
        log('Received SIGQUIT');
        return shutDownServer('SIGQUIT');
      });
      process.once('SIGHUP', function() {
        log('Received SIGHUP');
        return shutDownServer('SIGHUP');
      });
      process.once('SIGINT', function() {
        log('Received SIGINT');
        return process.exit();
      });
      process.once('SIGUSR2', function() {
        log('Received SIGUSR2');
        return shutDownAllWorker('SIGQUIT');
      });
      cluster.on('death', function(worker) {
        var exitCode;
        exitCode = worker.process.exitCode;
        log('worker ' + worker.pid + ' died');
        if (!o.doNotForkNew) {
          log('worker ' + "(" + worker.process.pid + ') exited with code ' + exitCode + '. Restarting...');
          cluster.fork();
          return updateMasterPID();
        }
      });
      cluster.on('exit', function(worker, code, signal) {
        var exitCode;
        exitCode = worker.process.exitCode;
        if (exitCode === 7 || o.doNotForkNew) {
          return log('worker ' + "(" + worker.process.pid + ') exited with code ' + exitCode + ' permanently.');
        } else {
          log('worker ' + "(" + worker.process.pid + ') exited with code ' + exitCode + '. Restarting...');
          cluster.fork();
          return updateMasterPID();
        }
      });
      cluster.on('online', function(worker) {
        return log('Worker ' + worker.process.pid + ' is online');
      });
      eachWorker = function(callback) {
        var i, ref, results, v;
        ref = cluster.workers;
        results = [];
        for (i in ref) {
          v = ref[i];
          results.push(callback(v));
        }
        return results;
      };
      shutDownAllWorker = function(sig) {
        log("Closing All Worker Threads.");
        return eachWorker(function(worker) {
          return worker.send({
            cmd: "stop"
          });
        });
      };
      shutDownServer = function(sig) {
        sig = sig || 0;
        shutDownAllWorker(sig);
        return setTimeout(function() {
          log("Closing Master");
          log('Exiting.');
          return process.exit(0);
        }, 100);
      };
      restartAllWorker = function() {
        log("Restarting All Worker Threads.");
        return eachWorker(function(worker) {
          return worker.send({
            cmd: "restart"
          });
        });
      };
      getWorkers = function() {
        var i, ref, result, v;
        result = [];
        ref = cluster.workers;
        for (i in ref) {
          v = ref[i];
          result.push(v);
        }
        return result;
      };
      cluster.shutDownServer = shutDownServer;
      cluster.shutDownAllWorker = shutDownAllWorker;
      cluster.eachWorker = eachWorker;
      cluster.getWorkers = getWorkers;
      log('Master cluster setting up ' + numWorkers + ' workers...');
      arr = [];
      for (i = j = 1, ref = numWorkers; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        arr.push(i);
      }
      o.masterpid = process.id;
      o.cluster = cluster;
      return async.mapLimit(arr, 4, function(i, cb) {
        cluster.fork();
        return cb();
      }, function(e, r) {
        return setTimeout(function() {
          if (o.checkMaster) {
            updateMasterPID();
          }
          return cb(e, o);
        }, 3000);
      });
    } else {
      closeWorker = function(sig) {
        sig = sig || 0;
        log("Closing Worker " + cluster.worker.id);
        process._channel.close();
        process._channel.unref();
        return process.exit(sig);
      };
      process.on('message', function(msg) {
        if (msg.cmd && (msg.cmd === 'stop' || msg.cmd === "terminate")) {
          return closeWorker(7);
        } else if (msg.cmd && msg.cmd === 'restart') {
          return closeWorker(0);
        }
      });
      if (o.checkMaster) {
        setInterval(function() {
          var e;
          try {
            if (masterpid) {
              return running(masterpid, function(err, live) {
                if (err) {
                  return log.info('failed to retrieve master running state');
                } else {
                  if (live !== true) {
                    return closeWorker(7);
                  }
                }
              });
            }
          } catch (error) {
            e = error;
          }
        }, 60000);
      }
      return payload(o);
    }
  };

  exports.forkCluster = forkCluster;

  exports.gqworker = {
    runAsThread: runAsThread,
    threadHandler: threadHandler,
    forkCluster: forkCluster
  };

}).call(this);
